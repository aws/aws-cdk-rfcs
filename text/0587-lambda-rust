# AWS Lambda Rust function L2 Construct

* **Original Author(s):**: @SteveHouel
* **Tracking Issue**: #587
* **API Bar Raiser**: @{BAR_RAISER_USER}

This library provides constructs and tooling to simplify Rust  function developement, packaging process and accelerate your deployment to AWS Lambda.

## Working Backwards

The following is ReadMe for AWS Lambda Rust function construct.

### Amazon Lambda Rust Library

This library provides constructs for Rust Lambda functions.

The `RustFunction` construct creates a Lambda function with automatic building and bundling of Rust code.

To use this module you will either need to have `cargo-lambda` installed or Docker installed.

See Local Bundling/Docker Bundling for more information.

This module also required that `aarch64-unknown-linux-gnu` toolchain has been installed.

#### Rust Function

By default, the construct will use directory where cdk was invoked as directory where Cargo file is located.

```plaintext
.
├── Cargo.toml
└── src
    └── main.rs
```

It will use the package name as defined in the main `Cargo.toml`:

```typescript
new RustFunction(this, "my_function");
```

Alternatively, `bin` and `directory` properties can be specified to override this default behavior.

```typescript
new RustFunction(this, "my-function", {
    directory: '/path/to/directory/with/Cargo.toml',
    // Optional
    bin: 'my_function',
});
```

For more complex project structure combining multiple Rust Lambda function, the construct offer the ability to use [Workspaces](https://doc.rust-lang.org/book/ch14-03-cargo-workspaces.html) defined in your Cargo project.

Given a sample project structure:

```plaintext
.
├── Cargo.toml
├── my_lambda_1
│   ├── Cargo.toml
│   └── src
│       └── main.rs
└── my_lambda_2
    ├── Cargo.toml
    └── src
        └── main.rs
```

And with a given `Cargo.toml`:

```toml
[workspace]
members = [
    "my_lambda_1",
    "my_lambda_2"
]
```

Rust functions can be declared using `package` properties:

```typescript
new RustFunction(this, 'FirstFunction', {
    package: 'my_lambda_1',
});

new RustFunction(this, 'SecondFunction', {
    package: 'my_lambda_2',
});
```

#### Customizing the underlying Lambda function

All properties of lambda.Function can be used to customize the underlying lambda.Function.

See also the [AWS Lambda construct library](https://github.com/aws/aws-cdk/tree/main/packages/aws-cdk-lib/aws-lambda).

#### Local Bundling

If `cargo-lambda` is available it will be used to bundle your code in your environment. Otherwise, bundling will happen in a Lambda compatible
Docker container with the Docker platform based on the target architecture of the Lambda function and with all required tools.

`cargo-lambda` can be installed with:

```bash
cargo install cargo-lambda
```

Or for macOS and Linux users, you can also use Homebrew:

```bash
brew tap cargo-lambda/cargo-lambda
brew install cargo-lambda
```

By default, cargo-lambda compiles the code for Linux ARM architectures, you can compile for X86-64 architectures by providing the right property:

```typescript
new RustFunction(this, 'my_function', {
  architecture: lambda.Architecture.X86-64
});
```

Toolchain `aarch64-unknown-linux-gnu` must be installed to allow cargo-lambda to build for **Linux ARM** target.

To force bundling in a Docker container even if `cargo-lambda` is available in your environment, set `bundling.forceDockerBundling` to true.

This is useful if your function relies on Rust crates that should be installed in a Lambda compatible environment.
This is usually the case with modules using native dependencies or specific processor architecture.

#### Customizing Docker bundling

Use `bundling.environment` to define environments variables when `cargo lambda` runs:

```typescript
new RustFunction(this, 'my_function', {
  bundling: {
    environment: {
      CARGO_LAMBDA_COMPILER: 'cargo',
    },
  },
});
```

Use the `bundling.buildArgs` to pass build arguments to `cargo lambda`:

```typescript
new go.RustFunction(this, 'my_function', {
  bundling: {
    buildArgs: ['--all-features'],
  },
});
```

Use the `bundling.dockerImage` to use a custom Docker bundling image:

```typescript
new go.RustFunction(this, 'my_function', {
  bundling: {
    dockerImage: DockerImage.fromBuild('/path/to/Dockerfile'),
  },
});
```

You can set additional Docker options to configure the build environment:

```typescript
new RustFunction(this, 'my_function', {
 bundling: {
     network: 'host',
     securityOpt: 'no-new-privileges',
     user: 'user:group',
     volumesFrom: ['777f7dc92da7'],
     volumes: [{ hostPath: '/host-path', containerPath: '/container-path' }],
  },
});
```

#### Command hooks

It is possible to run additional commands by specifying the commandHooks prop:

```typescript
// This example only available in TypeScript
// Run additional props via `commandHooks`
new RustFunction(this, 'my_function_with_commands', {
  bundling: {
    commandHooks: {
      beforeBundling(inputDir: string, outputDir: string): string[] {
        return [
          `echo hello > ${inputDir}/a.txt`,
          `cp ${inputDir}/a.txt ${outputDir}`,
        ];
      },
      afterBundling(inputDir: string, outputDir: string): string[] {
        return [`cp ${inputDir}/b.txt ${outputDir}/txt`];
      },
      beforeInstall() {
        return [];
      },
      // ...
    },
    // ...
  },
});
```

The following hooks are available:

- **beforeBundling**: runs before all bundling commands
- **beforeInstall**: runs before Cargo crates installation
- **afterBundling**: runs after all bundling commands

They all receive the directory containing the lock file (inputDir) and the directory where the bundled asset will be output (outputDir).
They must return an array of commands to run. Commands are chained with &&.

The commands will run in the environment in which bundling occurs: inside the container for Docker bundling or on the host OS for local bundling.

---

Ticking the box below indicates that the public API of this RFC has been
signed-off by the API bar raiser (the `status/api-approved` label was applied to the
RFC pull request):

```
[ ] Signed-off by API Bar Raiser @xxxxx
```

## Public FAQ

### What are we launching today?

We are launching L2 support for Rust Lambda function.

This module has been create to help customers in all their development phases to build,
package and deploy Lambda function when using Rust programming language.

### Why should I use this feature?

You should use this feature if,

* You will build a new Rust project based on AWS Lambda function.
Not need anymore to execute independentely every lifecycle steps of your Rust project. From crates install, code build and package,
every development steps will be handle by this new module.

## Internal FAQ

### Why are we doing this?

Rust Lambda function L2 support has been requested by our users for a long time.

Today, building, optimizing, packaging and deploying  an AWS Lambda Rust function is not a straightforward task and
it can be complex for developers to handle this process when defining a CI/CD pipeline.
It require multiple steps and optimization to build and package a function to the targeted system architecture binary and make it ready for depoloyment.

This module main objective is to simplify AWS CDK integration with Rust projects and improve customer experience when using both technologies.

### Why should we _not_ do this?

> Is there a way to address this use case with the current product? What are the
> downsides of implementing this feature?

### What is the technical solution (design) of this feature?

> Briefly describe the high-level design approach for implementing this feature.
>
> As appropriate, you can add an appendix with a more detailed design document.
>
> This is a good place to reference a prototype or proof of concept, which is
> highly recommended for most RFCs.

### Is this a breaking change?

> If the answer is no. Otherwise:
>
> Describe what ways did you consider to deliver this without breaking users?
>
> Make sure to include a `BREAKING CHANGE` clause under the CHANGELOG section with a description of the breaking
> changes and the migration path.

### What alternative solutions did you consider?

> Briefly describe alternative approaches that you considered. If there are
> hairy details, include them in an appendix.

### What are the drawbacks of this solution?

> Describe any problems/risks that can be introduced if we implement this RFC.

### What is the high-level project plan?

> Describe your plan on how to deliver this feature from prototyping to GA.
> Especially think about how to "bake" it in the open and get constant feedback
> from users before you stabilize the APIs.
>
> If you have a project board with your implementation plan, this is a good
> place to link to it.

### Are there any open issues that need to be addressed later?

> Describe any major open issues that this RFC did not take into account. Once
> the RFC is approved, create GitHub issues for these issues and update this RFC
> of the project board with these issue IDs.

## Appendix

Feel free to add any number of appendices as you see fit. Appendices are
expected to allow readers to dive deeper to certain sections if they like. For
example, you can include an appendix which describes the detailed design of an
algorithm and reference it from the FAQ.
