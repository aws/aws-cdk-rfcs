# AWS DynamoDB Global Table L2 Construct

* **Original Author(s):**: @vinayak-kukreja
* **Tracking Issue**: #510
* **API Bar Raiser**: @rix0rrr

Users will now be able to replicate their DynamoDB table to multiple regions using the Global Table L2 construct. This feature would be using the CloudFormation resource for global table and users would no longer need to rely custom resources from provisioning global tables.

## Working Backwards

The following is ReadMe for DynamoDB Global Table:

### DynamoDB Global Table

[DynamoDB Global Table](https://aws.amazon.com/dynamodb/global-tables/) lets you provision a table that could be replicated across different regions. It could also be deployed to just one region and would cost the same as a single DynamoDB table.

#### Partition Key

Our GlobalTable L2 construct could be used to provision a global table. You can do this as follows,

```typescript
  new GlobalTable(stack, 'FooTable', {
    partitionKey: { name: 'Foo', type: AttributeType.STRING },
  });
```

This would provision a global table only in the region where the stack is being deployed to. The provisioning mode would be on-demand. And, it would also add a partition key which would be the same for all replicas of the table.

#### Sort Key

You can add a sort key to your global table. This sort key would be the same across all replicas of the table.

```typescript
  new GlobalTable(stack, 'FooTable', {
    partitionKey: { name: 'Foo', type: AttributeType.STRING },
    sortKey: { name: 'Bar', type: AttributeType.STRING },
  });
```

#### Table Name

You can mention a name for your global table. If not specified, this is auto generated by cloudformation. This would be the same for each replica.

```typescript
  new GlobalTable(stack, 'FooTable', {
    partitionKey: { name: 'Foo', type: AttributeType.STRING },
    tableName: 'FooBarTable',
  });
```

#### Billing Mode

There are two billing modes that global tables could have,
  1. Pay Per Request: In this mode you would not need to specify write or read capacity. You would only be paying for the capacity utilized by the requests coming in.
  2. Provisioned: In this mode you would have write with auto scaling and read capacity with either auto scaling or with exact read capacity units. You would be paying for the provisioned capacity even if it is not utilized.

The default mode is pay per request mode. If you choose provisioned mode, then you would need to specify read and write capacity for the table and replicas. You can do this in three ways, 
  1. Mention capacity on table level and these get copied over to all replicas.
  2. Mention capacity for each replica separately.
  3. Mention capacity on table level and for replica where you want to have a different capacity. Wherever you would not mention capacity, the table level values would be used.

The billing mode will remain the same across all replicas.

##### Pay Per Request Mode

```typescript
  new GlobalTable(stack, 'FooTable', {
    partitionKey: { name: 'Foo', type: AttributeType.STRING },
    billingMode: BillingMode.PAY_PER_REQUEST,
  });
```

##### Provisioned Mode

* __Table level configuration with auto scaling__

```typescript
  new GlobalTable(stack, 'FooTable', {
    partitionKey: { name: 'Foo', type: AttributeType.STRING },
    billingMode: BillingMode.PROVISIONED,
    writeWithAutoScaling: {
      max: 50,
    },
    readWithAutoScaling: {
      max: 50,
    },
  });
```

* __Table level configuration read capacity without auto scaling__

```typescript
  new GlobalTable(stack, 'FooTable', {
    partitionKey: { name: 'Foo', type: AttributeType.STRING },
    billingMode: BillingMode.PROVISIONED,
    writeWithAutoScaling: {
      max: 50,
    },
    readCapactity: 50,
  });
```

__NOTE:__
  * Provisioned mode for write capacity could only be used with autoscaling. There is no way to provision an exact write capacity unit in global tables.
  * Write capacity could not be configured on a per replica basis. You can only modify read capacity per replica. 
  * You can either define `readCapacity` or `readWithAutoScaling` but not both at the same time.

#### Global Secondary Indexes

You can add global secondary indexes to your global table. These would be the same for each replica of the table. There is some configuration that could be specified per replica. 

```typescript
  const globalTable = new GlobalTable(stack, 'FooTable', {
    partitionKey: { name: 'Foo', type: AttributeType.STRING },
    sortKey: { name: 'Bar', type: AttributeType.STRING },
    globalSecondaryIndex: [
      {
        indexName: 'FooTableGsi',
        partitionKey: { name: 'Bar', type: AttributeType.STRING },
      },
    ],
  });
```

You can add global secondary index with `addGlobalSecondaryIndex` method. 

```typescript
  globalTable.addGlobalSecondaryIndex({
    indexName: 'FooTableGsi',
    partitionKey: { name: 'Bar', type: AttributeType.STRING },
  });
```

__NOTE:__
  * You can create up to 20 global secondary indexes.
  * You can only create or delete one global secondary index in a single stack operation.

#### Local Secondary Indexes

You can add local secondary indexes to your global table. These would be the same for each replica of the table. 

```typescript
  const globalTable = new GlobalTable(stack, 'FooTable', {
    partitionKey: { name: 'Foo', type: AttributeType.STRING },
    sortKey: { name: 'Bar', type: AttributeType.STRING },
    localSecondaryIndex: [
      {
        indexName: 'FooTableLsi',
        sortKey: { name: 'Foo', type: AttributeType.STRING },
      },
    ],
  });
```

You can add local secondary index with `addLocalSecondaryIndex` method. 

```typescript
  globalTable.addLocalSecondaryIndex({
    indexName: 'FooTableLsi',
    sortKey: { name: 'Foo', type: AttributeType.STRING },
  });
```

__NOTE:__
  * You need a sort key to define a local secondary index.
  * You can create up to five local secondary indexes.

#### Encryption

There are three types of encryptions that are available for global tables.
  1. `AWS_OWNED`: This uses a KMS key for encryption that is owned by DynamoDB. This is the default for global tables.
  2. `AWS_MANAGED`: A KMS key is created in your account and is managed by AWS.
  3. `CUSTOMER_MANAGED`: You can specify a KMS key that is managed by you for encrytion.

This would be the same for each replica.

```typescript
  new GlobalTable(stack, 'FooTable', {
    partitionKey: { name: 'Foo', type: AttributeType.STRING },
    encryption: TableEncryption.AWS_MANAGED,
  });
```

__NOTE__:
  * If the encryption mode is CUSTOMER_MANAGED, then you would need to specify a KMS key for each replica.

#### Streams

You can enable DynamoDB streams for your global tables. There are four possible values for it,
  1. `NEW_IMAGE`: The entire item, as it appears after it was modified, is written to the stream.
  2. `OLD_IMAGE`: The entire item, as it appeared before it was modified, is written to the stream.
  3. `NEW_AND_OLD_IMAGES`: Both the new and the old item images of the item are written to the stream.
  4. `KEYS_ONLY`: Only the key attributes of the modified item are written to the stream.

This would be the same for each replica. By default, streams are not enabled for global table. But, if you have a replica present which is not of the same region as where the stack is deployed to, then the stream type would be set to `NEW_AND_OLD_IMAGES` automatically since it is required for table replication.

```typescript
  new GlobalTable(stack, 'FooTable', {
    partitionKey: { name: 'Foo', type: AttributeType.STRING },
    stream: StreamViewType.NEW_IMAGE,
  });
```

#### Time To Live

You can enable time to live for an attribute of the global table. This would be the same for each replica. By default, it is not enabled for any attributes.

```typescript
  new GlobalTable(stack, 'FooTable', {
    partitionKey: { name: 'Foo', type: AttributeType.STRING },
    timeToLiveAttribute: 'Foo',
  });
```

#### Replicas

You can define replicas for your global table. By default, if this configuration is undefined, then the table is deployed to the region where stack is being deployed.

```typescript
  const globalTable = new GlobalTable(stack, 'FooTable', {
    partitionKey: { name: 'Foo', type: AttributeType.STRING },
    replicas: [
      {
        region: 'us-east-1',
      },
      {
        region: 'us-west-2',
      },
    ],
  });
```

There are per replica configurations that are available. If any of these are undefined in the replica and defined in the table level props, then those are copied over to the replica configuration.
But, if the replica has any configuration that is defined and the tabel level properties are defined as well, then the replica property value takes precedence and would be assigned. 

Options:
  * `region` --> Needs to be specified
  * `contributorInsightsEnabled` --> Gets copied over from table level props if defined. 
  * `deletionProtection` --> Gets copied over from table level props if defined. 
  * `pointInTimeRecovery` --> Gets copied over from table level props if defined. 
  * `tableClass` --> Gets copied over from table level props if defined. 
  * `tags` --> Gets copied over from table level props if defined. 
  * `readWithAutoScaling` --> Gets copied over from table level props if defined. 
  * `readCapactity` --> Gets copied over from table level props if defined. 
  * `encryptionKey` --> This needs to be defined per replica
  * `kinesisStream` --> This needs to be defined per replica
  * `gsiProps`
      * `indexName` --> Needs to be specified
      * `contributorInsightsEnabled` --> Gets copied over from table level props or replica level props if defined. 

You can also add a replica using `addReplica` method.

```typescript
  globalTable.addReplica({
    region: 'us-east-1',
  });
```

__NOTE:__
  * A replica needs to be deployed to the region where stack is deployed to. We do this automatically if user has not defined the region in replica.

#### Grants

You can grant access to certain operation on the table with the help of `grant` functions.

```typescript
  const globalTable = new GlobalTable(stack, 'FooTable', {
    partitionKey: { name: 'Foo', type: AttributeType.STRING },
    replicas: [
      {
        region: 'us-west-2',
      },
    ],
  });

  const lambdaRole = new iam.Role(stack, 'Role', {
    assumedBy: new iam.ServicePrincipal('lambda.amazonaws.com'),
  });

  globalTable.grantReadData(lambdaRole, ['us-west-2']);
```

#### Metrics

You can access metrics emitted by global table by using `metric` functions. 

```typescript
  const globalTable = new GlobalTable(stack, 'FooTable', {
    partitionKey: { name: 'Foo', type: AttributeType.STRING },
    replicas: [
      {
        region: 'us-west-2',
      },
    ],
  });

  const metric = globalTable.metricConsumedWriteCapacityUnits({
    region: 'us-west-2',
  });
```

#### Importing

You can import an existing global table in your stack by using `from` functions. You would need to specify either table name, table arn or table attributes to import it.

```typescript
GlobalTable.fromTableName(stack, 'FooTableId', 'FooTable');
```

### NOTE
  * Be careful while naming your global table. If there is a name conflict in a region with a DynamoDB table, that could lead to removal of that table with the global table replica.
  * We only support version [2019.11.21](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/globaltables.V2.html) of the global table since CloudFormation just has support for the same. 

---

Ticking the box below indicates that the public API of this RFC has been
signed-off by the API bar raiser (the `api-approved` label was applied to the
RFC pull request):

```
[ ] Signed-off by API Bar Raiser @xxxxx
```

## Public FAQ

### What are we launching today?

We are launching L2 support for DynamoDB Global Table feature.

### Why should I use this feature?

You should use this feature if you would like to provision a DynamoDB table that has the capability of replicating to other regions. This would remove the need of creating custom solution for replicating your table to other regions and decrease maintenance load.

## Internal FAQ

### Why are we doing this?

DynamoDB Global table L2 support has been requested by our users for a long time. When CDK initally added support for this feature, CloudFormation support for global tables did not exist. So we had to use [custom CloudFormation resources](https://docs.aws.amazon.com/cdk/api/v2/docs/aws-cdk-lib.custom_resources-readme.html) within our [Table construct](https://docs.aws.amazon.com/cdk/api/v2/docs/aws-cdk-lib.aws_dynamodb-readme.html#amazon-dynamodb-global-tables) to add support for this feature. 

The current implementation has some limitations,
  * Some properties are not propagated across replicas.
    * Open Issues: 
      * https://github.com/aws/aws-cdk/issues/25740
      * https://github.com/aws/aws-cdk/issues/25443
      * https://github.com/aws/aws-cdk/issues/18582
  * Customer managed key is not supported with replicationRegions in current solution. (Issues: https://github.com/aws/aws-cdk/issues/15957)

The current solution also would add maintenance load and cost for custom resource in user stack. And also blocks users who do not want to use a custom resource solution for provisioning their global tables.

This implementation moves away from the custom resource solution and to the user experience that global table intented to provide. With CloudFormation now having support for global table resource, we can now add L2 support for this feature. 

### Why should we _not_ do this?

We currently offer two solution to provision a global table,
  
  1. Custom CloudFormation Resource within Table construct
  2. L1 for global table resource

This means the customer is not blocked to use global tables. Adding L2 support would take up developer time and effort and, would also add to maintenance load for the CDK team. 

### What is the technical solution (design) of this feature?

#### `shared.ts`

The L1 for global table is quite similar to the L1 for table. This also reflects in the proposed L2, so I am creating a `shared.ts` hosting the code that is being shared among both the constructs.

* `AttributeType` Enum

  ```typescript
  /**
  * Data types for attributes within a table
  *
  * @see https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.NamingRulesDataTypes.html#HowItWorks.DataTypes
  */
  export enum AttributeType {
    /** Up to 400KiB of binary data (which must be encoded as base64 before sending to DynamoDB) */
    BINARY = 'B',
    /** Numeric values made of up to 38 digits (positive, negative or zero) */
    NUMBER = 'N',
    /** Up to 400KiB of UTF-8 encoded text */
    STRING = 'S',
  }
  ```

* `BillingMode` Enum

  ```typescript
  /**
   * DynamoDB's Read/Write capacity modes.
   */
  export enum BillingMode {
    /**
     * Pay only for what you use. You don't configure Read/Write capacity units.
     */
    PAY_PER_REQUEST = 'PAY_PER_REQUEST',
    /**
     * Explicitly specified Read/Write capacity units.
     */
    PROVISIONED = 'PROVISIONED',
  }
  ```

* `ProjectionType` Enum

  ```typescript
  /**
   * The set of attributes that are projected into the index
   *
   * @see https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_Projection.html
   */
  export enum ProjectionType {
    /** Only the index and primary keys are projected into the index. */
    KEYS_ONLY = 'KEYS_ONLY',
    /** Only the specified table attributes are projected into the index. The list of projected attributes is in `nonKeyAttributes`. */
    INCLUDE = 'INCLUDE',
    /** All of the table attributes are projected into the index. */
    ALL = 'ALL'
  }
  ```

* `TableEncryption` Enum

  ```typescript
  /**
   * What kind of server-side encryption to apply to this table.
   */
  export enum TableEncryption {
    /**
     * Server-side KMS encryption with a master key owned by AWS.
     */
    DEFAULT = 'AWS_OWNED',

    /**
     * Server-side KMS encryption with a customer master key managed by customer.
     */
    CUSTOMER_MANAGED = 'CUSTOMER_MANAGED',

    /**
     * Server-side KMS encryption with a master key managed by AWS.
     */
    AWS_MANAGED = 'AWS_MANAGED',
  }
  ```

* `StreamViewType` Enum

  ```typescript
  /**
   * When an item in the table is modified, StreamViewType determines what information
   * is written to the stream for this table.
   *
   * @see https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_StreamSpecification.html
   */
  export enum StreamViewType {
    /** The entire item, as it appears after it was modified, is written to the stream. */
    NEW_IMAGE = 'NEW_IMAGE',
    /** The entire item, as it appeared before it was modified, is written to the stream. */
    OLD_IMAGE = 'OLD_IMAGE',
    /** Both the new and the old item images of the item are written to the stream. */
    NEW_AND_OLD_IMAGES = 'NEW_AND_OLD_IMAGES',
    /** Only the key attributes of the modified item are written to the stream. */
    KEYS_ONLY = 'KEYS_ONLY'
  }
  ```

* `TableClass` Enum

  ```typescript
  /**
   * DynamoDB's table class.
   *
   * @see https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.TableClasses.html
   */
  export enum TableClass {
    /** Default table class for DynamoDB. */
    STANDARD = 'STANDARD',

    /** Table class for DynamoDB that reduces storage costs compared to existing DynamoDB Standard tables. */
    STANDARD_INFREQUENT_ACCESS = 'STANDARD_INFREQUENT_ACCESS',
  }
  ```

* `Operation` Enum

  ```typescript
  /**
   * Supported DynamoDB table operations.
   */
  export enum Operation {
    /** GetItem */
    GET_ITEM = 'GetItem',

    /** BatchGetItem */
    BATCH_GET_ITEM = 'BatchGetItem',

    /** Scan */
    SCAN = 'Scan',

    /** Query */
    QUERY = 'Query',

    /** GetRecords */
    GET_RECORDS = 'GetRecords',

    /** PutItem */
    PUT_ITEM = 'PutItem',

    /** DeleteItem */
    DELETE_ITEM = 'DeleteItem',

    /** UpdateItem */
    UPDATE_ITEM = 'UpdateItem',

    /** BatchWriteItem */
    BATCH_WRITE_ITEM = 'BatchWriteItem',

    /** TransactWriteItems */
    TRANSACT_WRITE_ITEMS = 'TransactWriteItems',

    /** TransactGetItems */
    TRANSACT_GET_ITEMS = 'TransactGetItems',

    /** ExecuteTransaction */
    EXECUTE_TRANSACTION = 'ExecuteTransaction',

    /** BatchExecuteStatement */
    BATCH_EXECUTE_STATEMENT = 'BatchExecuteStatement',

    /** ExecuteStatement */
    EXECUTE_STATEMENT = 'ExecuteStatement',
  }
  ```

* `Attribute` Interface

  ```typescript
  /**
   * Represents an attribute for describing the key schema for the table
   * and indexes.
   */
  export interface Attribute {
    /**
     * The name of an attribute.
     */
    readonly name: string;

    /**
     * The data type of an attribute.
     */
    readonly type: AttributeType;
  }
  ```

* `SchemaOptions` Interface

  ```typescript
  /**
   * Represents the table schema attributes.
   */
  export interface SchemaOptions {
    /**
     * Partition key attribute definition.
     */
    readonly partitionKey: Attribute;

    /**
     * Sort key attribute definition.
     *
     * @default no sort key
     */
    readonly sortKey?: Attribute;
  }
  ```

* `SecondaryIndexProps` Interface

  ```typescript
  /**
   * Properties for a secondary index
   */
  export interface SecondaryIndexProps {
    /**
     * The name of the secondary index.
     */
    readonly indexName: string;

    /**
     * The set of attributes that are projected into the secondary index.
     * @default ALL
     */
    readonly projectionType?: ProjectionType;

    /**
     * The non-key attributes that are projected into the secondary index.
     * @default - No additional attributes
     */
    readonly nonKeyAttributes?: string[];
  }
  ```

* `LocalSecondaryIndexProps` Interface

  ```typescript
  /**
   * Properties for a local secondary index
   */
  export interface LocalSecondaryIndexProps extends SecondaryIndexProps {
    /**
     * The attribute of a sort key for the local secondary index.
     */
    readonly sortKey: Attribute;
  }
  ```

* `TableSpecificOptions` Interface

  ```typescript
  /**
   * Represents options specific to each dynamodb table or replica table.
   */
  export interface TableSpecificOptions {
    /**
     * External KMS key to use for table encryption.
     *
     * This property can only be set if `encryption` is set to `TableEncryption.CUSTOMER_MANAGED`.
     *
     * @default - no KMS key is defined
     */
    readonly encryptionKey?: kms.IKey;

    /**
     * Kinesis Data Stream to capture item-level changes for the table.
     *
     * @default - no Kinesis Data Stream
     */
    readonly kinesisStream?: kinesis.IStream;
  }
  ```

* `TableSharedOptions` Interface

  ```typescript
  /**
   * Shared options between Table and GlobalTable
   */
  export interface TableSharedOptions {
    /**
     * Whether CloudWatch contributor insights is enabled.
     *
     * @default false
     */
    readonly contributorInsightsEnabled?: boolean;

    /**
     * Enables deletion protection for the table.
     *
     * @default false
     */
    readonly deletionProtection?: boolean;

    /**
     * Whether point-in-time recovery is enabled.
     * @default - point-in-time recovery is disabled
     */
    readonly pointInTimeRecovery?: boolean;

    /**
     * Specify the table class.
     * @default STANDARD
     */
    readonly tableClass?: TableClass;

    /**
     * Tags for the table
     *
     * @default - no tags
     */
    readonly tags?: CfnTag[];
  }
  ```

* `ITableShared` Interface

  ```typescript
  /**
   * Shared table interface between Table and GlobalTable
   */
  export interface ITableShared extends IResource {
    /**
     * Arn of the dynamodb table.
     *
     * @attribute
     */
    readonly tableArn: string;

    /**
     * Table name of the dynamodb table.
     *
     * @attribute
     */
    readonly tableName: string;

    /**
     * ARN of the table's stream, if there is one.
     *
     * @attribute
     */
    readonly tableStreamArn?: string;

    /**
     * Metric for the number of Errors executing all Lambdas
     */
    metric(metricName: string, props?: cloudwatch.MetricOptions): cloudwatch.Metric;

    /**
     * Metric for the consumed read capacity units
     *
     * @param props properties of a metric
     */
    metricConsumedReadCapacityUnits(props?: cloudwatch.MetricOptions): cloudwatch.Metric;

    /**
     * Metric for the consumed write capacity units
     *
     * @param props properties of a metric
     */
    metricConsumedWriteCapacityUnits(props?: cloudwatch.MetricOptions): cloudwatch.Metric;

    /**
     * Metric for the system errors this table
     *
     * @param props properties of a metric
     *
     */
    metricSystemErrorsForOperations(props?: SystemErrorsForOperationsMetricOptions): cloudwatch.IMetric;

    /**
     * Metric for the user errors
     *
     * @param props properties of a metric
     */
    metricUserErrors(props?: cloudwatch.MetricOptions): cloudwatch.Metric;

    /**
     * Metric for the conditional check failed requests
     *
     * @param props properties of a metric
     */
    metricConditionalCheckFailedRequests(props?: cloudwatch.MetricOptions): cloudwatch.Metric;

    /**
     * Metric for throttled requests
     *
     * @param props properties of a metric
     *
     */
    metricThrottledRequestsForOperations(props?: OperationsMetricOptions): cloudwatch.IMetric;

    /**
     * Metric for the successful request latency
     *
     * @param props properties of a metric
     *
     */
    metricSuccessfulRequestLatency(props?: cloudwatch.MetricOptions): cloudwatch.Metric;
  }
  ```

* `SystemErrorsForOperationsMetricOptions` Interface

  ```typescript
  /**
   * Options for configuring a system errors metric that considers multiple operations.
   */
  export interface SystemErrorsForOperationsMetricOptions extends cloudwatch.MetricOptions {

    /**
     * The operations to apply the metric to.
     *
     * @default - All operations available by DynamoDB tables will be considered.
     */
    readonly operations?: Operation[];

  }
  ```

* `OperationsMetricOptions` Interface

  ```typescript
    /**
     * Options for configuring metrics that considers multiple operations.
     */
    export interface OperationsMetricOptions extends SystemErrorsForOperationsMetricOptions {}
  ```

* `TableSharedAttributes` Interface

  ```typescript
  /**
   * Shared attributes between Table and GlobalTable
   */
  export interface TableSharedAttributes {
    /**
     * The ARN of the dynamodb table.
     * One of this, or `tableName`, is required.
     *
     * @default - no table arn
     */
    readonly tableArn?: string;

    /**
     * The table name of the dynamodb table.
     * One of this, or `tableArn`, is required.
     *
     * @default - no table name
     */
    readonly tableName?: string;

    /**
     * The ARN of the table's stream.
     *
     * @default - no table stream
     */
    readonly tableStreamArn?: string;

    /**
     * The name of the global indexes set for this Table.
     * Note that you need to set either this property,
     * or `localIndexes`,
     * if you want methods like grantReadData()
     * to grant permissions for indexes as well as the table itself.
     *
     * @default - no global indexes
     */
    readonly globalIndexes?: string[];

    /**
     * The name of the local indexes set for this Table.
     * Note that you need to set either this property,
     * or `globalIndexes`,
     * if you want methods like grantReadData()
     * to grant permissions for indexes as well as the table itself.
     *
     * @default - no local indexes
     */
    readonly localIndexes?: string[];

    /**
     * If set to true, grant methods always grant permissions for all indexes.
     * If false is provided, grant methods grant the permissions
     * only when `globalIndexes` or `localIndexes` is specified.
     *
     * @default - false
     */
    readonly grantIndexPermissions?: boolean;
  }
  ```

* `TableShared` Abstract Class

  ```typescript
  /**
   * Shared abstract class between Table and GlobalTable
   */
  export abstract class TableShared extends Resource {
    /**
     * @attribute
     */
    public abstract readonly tableArn: string;

    /**
     * @attribute
     */
    public abstract readonly tableName: string;

    /**
     * @attribute
     */
    public abstract readonly tableStreamArn?: string;

    /**
     * Return the given named metric for this Table
     *
     * By default, the metric will be calculated as a sum over a period of 5 minutes.
     * You can customize this by using the `statistic` and `period` properties.
     */
    public metric(metricName: string, props?: cloudwatch.MetricOptions): cloudwatch.Metric {}

    /**
     * Metric for the consumed read capacity units this table
     *
     * By default, the metric will be calculated as a sum over a period of 5 minutes.
     * You can customize this by using the `statistic` and `period` properties.
     */
    public metricConsumedReadCapacityUnits(props?: cloudwatch.MetricOptions): cloudwatch.Metric {}

    /**
     * Metric for the consumed write capacity units this table
     *
     * By default, the metric will be calculated as a sum over a period of 5 minutes.
     * You can customize this by using the `statistic` and `period` properties.
     */
    public metricConsumedWriteCapacityUnits(props?: cloudwatch.MetricOptions): cloudwatch.Metric {}

    /**
     * Metric for the user errors. Note that this metric reports user errors across all
     * the tables in the account and region the table resides in.
     *
     * By default, the metric will be calculated as a sum over a period of 5 minutes.
     * You can customize this by using the `statistic` and `period` properties.
     */
    public metricUserErrors(props?: cloudwatch.MetricOptions): cloudwatch.Metric {}

    /**
     * Metric for the conditional check failed requests this table
     *
     * By default, the metric will be calculated as a sum over a period of 5 minutes.
     * You can customize this by using the `statistic` and `period` properties.
     */
    public metricConditionalCheckFailedRequests(props?: cloudwatch.MetricOptions): cloudwatch.Metric {}

    /**
     * How many requests are throttled on this table
     *
     * Default: sum over 5 minutes
     *
     * @deprecated Do not use this function. It returns an invalid metric. Use `metricThrottledRequestsForOperation` instead.
     */
    public metricThrottledRequests(props?: cloudwatch.MetricOptions): cloudwatch.Metric {}

    /**
     * Metric for the successful request latency this table.
     *
     * By default, the metric will be calculated as an average over a period of 5 minutes.
     * You can customize this by using the `statistic` and `period` properties.
     */
    public metricSuccessfulRequestLatency(props?: cloudwatch.MetricOptions): cloudwatch.Metric {}

    /**
     * How many requests are throttled on this table, for the given operation
     *
     * Default: sum over 5 minutes
     */
    public metricThrottledRequestsForOperation(operation: string, props?: cloudwatch.MetricOptions): cloudwatch.Metric {}

    /**
     * How many requests are throttled on this table.
     *
     * This will sum errors across all possible operations.
     * Note that by default, each individual metric will be calculated as a sum over a period of 5 minutes.
     * You can customize this by using the `statistic` and `period` properties.
     */
    public metricThrottledRequestsForOperations(props?: OperationsMetricOptions): cloudwatch.IMetric {}

    /**
     * Metric for the system errors this table.
     *
     * This will sum errors across all possible operations.
     * Note that by default, each individual metric will be calculated as a sum over a period of 5 minutes.
     * You can customize this by using the `statistic` and `period` properties.
     */
    public metricSystemErrorsForOperations(props?: SystemErrorsForOperationsMetricOptions): cloudwatch.IMetric {}
  }
  ```

#### `global-table.ts`

This would be a file hosting the `GlobalTable` L2 construct. 

* `AutoScalingOptions` Interface

  ```typescript
  /**
   * Auto scaling options for read and write capacity.
   */
  export interface AutoScalingOptions {
    /**
     * Max provisioned capacity unit limit for auto scaling.
     */
    readonly max: number;

    /**
     * Min provisioned capacity unit limit for auto scaling.
     *
     * @default 1
     */
    readonly min?: number;

    /**
     * This capacity is used if switching provisioning mode.
     *
     * You need to specify this value for the table and its global secondary indexes. Cloudformation would
     * pick the higher value between seed and read capacity initally and will scale down, if a scaleInCooldown
     * is specified.
     *
     * @link http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-dynamodb-globaltable-capacityautoscalingsettings.html#cfn-dynamodb-globaltable-capacityautoscalingsettings-seedcapacity
     *
     * @default - No seed capacity defined since this would only be utilized with a provisioning mode switch.
     */
    readonly seed?: number;

    /**
     * Target utilization value for provisioned capacity
     *
     * @default 70
     */
    readonly target?: number;

    /**
     * The amount of time, in seconds, after a scale-in activity completes before another scale-in activity can start.
     *
     * @default Duration.seconds(5)
     */
    readonly scaleInCooldown?: Duration;

    /**
     * The amount of time, in seconds, after a scale-out activity completes before another scale-out activity can start.
     *
     * @default Duration.seconds(5)
     */
    readonly scaleOutCooldown?: Duration;
  }
  ```

* `ReadCapacityOptions` Interface

  ```typescript
  /**
   * Options for read capacity for tables or global secondary indexes.
   */
  export interface ReadCapacityOptions {
    /**
     * Configuration to enable auto scaling for read.
     *
     * This cannot be specified with readCapacity.
     *
     * @default - not defined if billing mode is on demand. You would need
     * to specify values if mode is provisioned.
     */
    readonly readWithAutoScaling?: AutoScalingOptions;

    /**
     * Provisioned read capacity.
     *
     * This cannot be specified with readWithAutoScaling.
     *
     * @default - not defined if billing mode is on demand. You would need
     * to specify values if mode is provisioned.
     */
    readonly readCapactity?: number;
  }
  ```

* `ReplicaGSIOptions` Interface

  ```typescript
  /**
   * Replica specific options for a global secondary indexes.
   */
  export interface ReplicaGSIOptions extends ReadCapacityOptions {
    /**
     * The name for the secondary index.
     * This must be unique across global secondary indexes.
     */
    readonly indexName: string;

    /**
     * Whether CloudWatch contributor insights is enabled.
     *
     * @default false
     */
    readonly contributorInsightsEnabled?: boolean;
  }
  ```

* `GlobalSecondaryIndexOptions` Interface

  ```typescript
  /**
   * Options for a global secondary index.
   */
  export interface GlobalSecondaryIndexOptions extends SecondaryIndexProps, SchemaOptions {
    /**
     * Configuration to enable auto scaling for write capacity.
     *
     * @default - not defined if billing mode is on demand. You would need
     * to specify values if mode is provisioned.
     */
    readonly writeWithAutoScaling?: AutoScalingOptions;
  }
  ```

* `ReplicaTableOptions` Interface

  ```typescript
  /**
   * Replica table options.
   */
  export interface ReplicaTableOptions extends TableSharedOptions, TableSpecificOptions, ReadCapacityOptions {
    /**
     * Region where table will be replicated.
     */
    readonly region: string;

    /**
     * Replica specific options for global secondary indexes.
     *
     * @default - If not specified, copies values from table level props.
     */
    readonly gsiProps?: ReplicaGSIOptions[];
  }
  ```


* `GlobalTableProps` Interface

  ```typescript
  /**
   * Global table properties.
   */
  export interface GlobalTableProps extends SchemaOptions, TableSharedOptions, ReadCapacityOptions {
    /**
     * Enforces a particular physical table name.
     *
     * This would be the same for each replica.
     *
     * @default <generated>
     */
    readonly tableName?: string;

    /**
     * Specify how you are charged for read and write throughput and how you manage capacity.
     *
     * This would be the same for each replica.
     *
     * @default PAY_PER_REQUEST
     */
    readonly billingMode?: BillingMode;

    /**
     * Auto scaling configuration for table writes.
     *
     * This needs to be specified if billing mode is provisioned.
     * The global secondary indexes would also have the same capacity
     * if none is specified for them.
     *
     * @default - This is not defined since default billing mode is on-demand.
     */
    readonly writeWithAutoScaling?: AutoScalingOptions;

    /**
     * List of replica table configuration.
     *
     * @default - single replica will be deployed in the region
     * where stack is being deployed.
     */
    readonly replicas?: ReplicaTableOptions[];

    /**
     * Encryption mode for the table. 
     *
     * This would be the same for each replica.
     *
     * If you set it to CUSTOMER_MANAGED, then you need to specify a kms key for each replica.
     *
     * @default - The table is encrypted with an encryption key managed by DynamoDB, and you are not charged any fee for using it.
     */
    readonly encryption?: TableEncryption;

    /**
     * When an item in the table is modified, StreamViewType determines what information
     * is written to the stream for this table.
     *
     * Note: If there is a replica other than the region stack is deployed to, then this value
     * would be switched to StreamViewType.NEW_AND_OLD_IMAGES to enable global table.
     *
     * @default - There would be no stream.
     */
    readonly stream?: StreamViewType;

    /**
     * The name of TTL attribute.
     *
     * This would be the same for each replica.
     *
     * @default - TTL is disabled.
     */
    readonly timeToLiveAttribute?: string;

    /**
     * Global Secondary Indexes.
     *
     * This would be the same for each replica.
     *
     * @default - No global secondary index defined for the table or its replicas.
     */
    readonly globalSecondaryIndex?: GlobalSecondaryIndexOptions[];

    /**
     * Local Secondary Indexes.
     *
     * This would be the same for each replica.
     *
     * @default - No local secondary index defined for the table or its replicas.
     */
    readonly localSecondaryIndex?: LocalSecondaryIndexProps[];

    /**
     * The removal policy to apply to the DynamoDB Table.
     * 
     * This would be the same for each replica if its not specified in 
     * the replica options.
     *
     * @default RemovalPolicy.RETAIN
     */
    readonly removalPolicy?: RemovalPolicy;
  }
  ```

* `IGlobalTable` Interface

  ```typescript
  /**
   * An interface that represents a DynamoDB Global Table - either created with the CDK, or an existing one.
   */
  export interface IGlobalTable extends ITableShared {
    /**
     * List of replica table configuration.
     */
    readonly replicas?: ReplicaTableOptions[];

    /**
     * Adds an IAM policy statement associated with this table or its replicas to an IAM
     * principal's policy.
     *
     * If `encryptionKey` is present, appropriate grants to the key needs to be added
     * separately using the `encryptionKey.grant*` methods.
     *
     * @param grantee The principal (no-op if undefined)
     * @param regions Regions where table needs to be accessed
     * @param actions The set of actions to allow (i.e. "dynamodb:PutItem", "dynamodb:GetItem", ...)
     */
    grant(grantee: iam.IGrantable, regions: string[], ...actions: string[]): iam.Grant;

    /**
     * Adds an IAM policy statement associated with this table's stream to an
     * IAM principal's policy.
     *
     * If `encryptionKey` is present, appropriate grants to the key needs to be added
     * separately using the `table.encryptionKey.grant*` methods.
     *
     * @param grantee The principal (no-op if undefined)
     * @param actions The set of actions to allow (i.e. "dynamodb:DescribeStream", "dynamodb:GetRecords", ...)
     */
    grantStream(grantee: iam.IGrantable, ...actions: string[]): iam.Grant;

    /**
     * Permits an IAM principal all data read operations from this table:
     * BatchGetItem, GetRecords, GetShardIterator, Query, GetItem, Scan.
     *
     * If `encryptionKey` is present, appropriate grants to the key needs to be added
     * separately using the `table.encryptionKey.grant*` methods.
     *
     * @param grantee The principal to grant access to.
     */
    grantReadData(grantee: iam.IGrantable, regions?: string[]): iam.Grant;

    /**
     * Permits an IAM Principal to list streams attached to current dynamodb table.
     *
     * @param grantee The principal (no-op if undefined).
     */
    grantTableListStreams(grantee: iam.IGrantable): iam.Grant;

    /**
     * Permits an IAM principal all stream data read operations for this
     * table's stream:
     * DescribeStream, GetRecords, GetShardIterator, ListStreams.
     *
     * If `encryptionKey` is present, appropriate grants to the key needs to be added
     * separately using the `table.encryptionKey.grant*` methods.
     *
     * @param grantee The principal to grant access to
     */
    grantStreamRead(grantee: iam.IGrantable): iam.Grant;

    /**
     * Permits an IAM principal all data write operations to this table:
     * BatchWriteItem, PutItem, UpdateItem, DeleteItem.
     *
     * If `encryptionKey` is present, appropriate grants to the key needs to be added
     * separately using the `table.encryptionKey.grant*` methods.
     *
     * @param grantee The principal to grant access to.
     */
    grantWriteData(grantee: iam.IGrantable, regions?: string[]): iam.Grant;

    /**
     * Permits an IAM principal to all data read/write operations to this table.
     * BatchGetItem, GetRecords, GetShardIterator, Query, GetItem, Scan,
     * BatchWriteItem, PutItem, UpdateItem, DeleteItem.
     *
     * If `encryptionKey` is present, appropriate grants to the key needs to be added
     * separately using the `table.encryptionKey.grant*` methods.
     *
     * @param grantee The principal to grant access to.
     */
    grantReadWriteData(grantee: iam.IGrantable, regions?: string[]): iam.Grant;

    /**
     * Permits all DynamoDB operations ("dynamodb:*") to an IAM principal.
     *
     * If `encryptionKey` is present, appropriate grants to the key needs to be added
     * separately using the `table.encryptionKey.grant*` methods.
     *
     * @param grantee The principal to grant access to.
     */
    grantFullAccess(grantee: iam.IGrantable, regions?: string[]): iam.Grant;
  }
  ```

* `GlobalTableAttributes` Interface

  ```typescript
  /**
   * Reference to a dynamodb global table.
   */
  export interface GlobalTableAttributes extends TableSharedAttributes {
    /**
     * List of replica table configuration.
     *
     * @default - single table configuration that will be deployed to the region
     * where stack is being deployed.
     */
    readonly replicas?: ReplicaTableOptions[];
  }
  ```

* `GlobalTableBase` Abstract Class

  ```typescript
  /**
   * Base class for global table.
   */
  abstract class GlobalTableBase extends TableShared implements IGlobalTable {
    /**
     *
     * @attribute
     */
    public abstract readonly tableArn: string;

    /**
     *
     * @attribute
     */
    public abstract readonly tableStreamArn?: string;

    /**
     * Adds an IAM policy statement associated with this table to an IAM
     * principal's policy.
     *
     * If `encryptionKey` is present, appropriate grants to the key needs to be added
     * separately using the `table.encryptionKey.grant*` methods.
     *
     * @param grantee The principal (no-op if undefined)
     * @param regions Regions where table needs to be accessed
     * @param actions The set of actions to allow (i.e. "dynamodb:PutItem", "dynamodb:GetItem", ...)
     */
    public grant(grantee: iam.IGrantable, actions: string[], regions: string[] = []): iam.Grant {}

    /**
     * Adds an IAM policy statement associated with this table's stream to an
     * IAM principal's policy.
     *
     * If `encryptionKey` is present, appropriate grants to the key needs to be added
     * separately using the `table.encryptionKey.grant*` methods.
     *
     * @param grantee The principal (no-op if undefined)
     * @param actions The set of actions to allow (i.e. "dynamodb:DescribeStream", "dynamodb:GetRecords", ...)
     */
    public grantStream(grantee: iam.IGrantable, ...actions: string[]): iam.Grant {}

    /**
     * Permits an IAM principal all data read operations from this table:
     * BatchGetItem, GetRecords, GetShardIterator, Query, GetItem, Scan, DescribeTable.
     *
     * If `encryptionKey` is present, appropriate grants to the key needs to be added
     * separately using the `table.encryptionKey.grant*` methods.
     *
     * @param grantee The principal to grant access to.
     */
    public grantReadData(grantee: iam.IGrantable, regions: string[] = []): iam.Grant {}

    /**
     * Permits an IAM Principal to list streams attached to current dynamodb table.
     *
     * @param grantee The principal (no-op if undefined).
     */
    public grantTableListStreams(grantee: iam.IGrantable): iam.Grant {}

    /**
     * Permits an IAM principal all stream data read operations for this
     * table's stream:
     * DescribeStream, GetRecords, GetShardIterator, ListStreams.
     *
     * If `encryptionKey` is present, appropriate grants to the key needs to be added
     * separately using the `table.encryptionKey.grant*` methods.
     *
     * @param grantee The principal to grant access to.
     */
    public grantStreamRead(grantee: iam.IGrantable): iam.Grant {}

    /**
     * Permits an IAM principal all data write operations to this table:
     * BatchWriteItem, PutItem, UpdateItem, DeleteItem, DescribeTable.
     *
     * If `encryptionKey` is present, appropriate grants to the key needs to be added
     * separately using the `table.encryptionKey.grant*` methods.
     *
     * @param grantee The principal to grant access to.
     */
    public grantWriteData(grantee: iam.IGrantable, regions: string[] = []): iam.Grant {}

    /**
     * Permits an IAM principal to all data read/write operations to this table.
     * BatchGetItem, GetRecords, GetShardIterator, Query, GetItem, Scan,
     * BatchWriteItem, PutItem, UpdateItem, DeleteItem, DescribeTable
     *
     * If `encryptionKey` is present, appropriate grants to the key needs to be added
     * separately using the `table.encryptionKey.grant*` methods.
     *
     * @param grantee The principal to grant access to.
     */
    public grantReadWriteData(grantee: iam.IGrantable, regions: string[] = []): iam.Grant {}

    /**
     * Permits all DynamoDB operations ("dynamodb:*") to an IAM principal.
     *
     * If `encryptionKey` is present, appropriate grants to the key needs to be added
     * separately using the `table.encryptionKey.grant*` methods.
     *
     * @param grantee The principal to grant access to.
     */
    public grantFullAccess(grantee: iam.IGrantable, regions: string[] = []) {}
  }
  ```

* `GlobalTable` Class

  ```typescript
  /**
   * Provides a DynamoDB Global Table
   */
  export class GlobalTable extends GlobalTableBase {

    /**
     * Creates a Global Table construct that represents an external global table via table name.
     *
     * @param scope The parent creating construct (usually `this`).
     * @param id The construct's name.
     * @param tableName The table's name.
     */
    public static fromTableName(scope: Construct, id: string, tableName: string): IGlobalTable {
      return GlobalTable.fromTableAttributes(scope, id, { tableName });
    }

    /**
     * Creates a Global Table construct that represents an external table via global table arn.
     *
     * @param scope The parent creating construct (usually `this`).
     * @param id The construct's name.
     * @param tableArn The table's ARN.
     */
    public static fromTableArn(scope: Construct, id: string, tableArn: string): IGlobalTable {
      return GlobalTable.fromTableAttributes(scope, id, { tableArn });
    }

    /**
     * Creates a Global Table construct that represents an external global table.
     *
     * @param scope The parent creating construct (usually `this`).
     * @param id The construct's name.
     * @param attrs A `GlobalTableAttributes` object.
     */
    public static fromTableAttributes(scope: Construct, id: string, attrs: GlobalTableAttributes): IGlobalTable {
      class Import extends GlobalTableBase {
        constructor(_tableArn: string, tableName: string, tableStreamArn?: string, replicas?: ReplicaTableOptions[]) {}
      }
    }

    /**
     * @attribute
     */
    public readonly tableArn: string;

    /**
     * @attribute
     */
    public readonly tableName: string;

    /**
     * @attribute
     */
    public readonly tableStreamArn: string | undefined;

    constructor(scope: Construct, id: string, props: GlobalTableProps) {}

    /**
     * Add a global secondary index of global table.
     *
     * @param props the property of global secondary index
     */
    public addGlobalSecondaryIndex(props: GlobalSecondaryIndexOptions) {}

    /**
     * Add a local secondary index of global table.
     *
     * @param props the property of local secondary index
     */
    public addLocalSecondaryIndex(props: LocalSecondaryIndexProps) {}

    /**
     * Add a replica for the global table
     *
     * @param replica
     * @param globalProps
     */
    public addReplica(replica: ReplicaTableOptions, globalProps: GlobalTableProps) {}
  }
  ```

__Callout__: 

  * The grant stream functions would not be able to grant stream access to replicas other than the one deployed in the stack region. This is due to the format of the stream arn which has format: _arn:aws:dynamodb:region:account-id:table/table-name/stream/timestamp_. 
  
  For [example](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-dynamodb-globaltable.html#aws-resource-dynamodb-globaltable-return-values),

  ```
  arn:aws:dynamodb:us-east-1:123456789012:table/testddbstack-myDynamoDBTable-012A1SL7SMP5Q/stream/2015-11-30T20:10:00.000
  ```
  
  Due to this, there is no way to reconstruct it for another region since we would not be aware of the timestamp value. If we want to support this, we can add a lookup function to determine the stream arn or create a CloudFormation custom resource.

### Is this a breaking change?

This is not a breaking change. This is adding functionality to CDK library.

### What alternative solutions did you consider?

#### Defaults for read and write capacity

In the proposed solution, if a user selects billing mode as provisioned, then they would need to specify values for read and write capacities. There are no defaults assigned in this solution. 

In my opinion, if a user is using the provisioned mode, then they must make conscious decisions about what the capacity should look like for the table and its replicas. 

#### Kms key not created for customer managed keys

In the proposed solution, if a user specifies customer managed key as their choice on encryption, then they would need to specify a key for each replica. 

Unlike the Table construct, I am not creating the KMS keys for the customers. I believe customer is making a conscious decision of using such encryption and should add relevant keys. 

To mitigate customer pain in this scenario, we can use a [multi region kms key](https://docs.aws.amazon.com/kms/latest/developerguide/multi-region-keys-overview.html) and provision that if none is present. 

### What are the drawbacks of this solution?

#### Code Redundancy and maintainance

This solution uses a lot of code that is shared with the Table construct. Even if we try to maximize the code shared between Table and Global Table constructs, there would still be some repeated code in each of these. This could lead to added maintenance load in the long run since an update to the repeated code in one of construct probably would need to be reflected in other as well. If such an update is missed in one of the construct, it could lead to customer pain. 

### What is the high-level project plan?

After this RFC is approved, I will start with implemetation and adding necessary tests.

### Are there any open issues that need to be addressed later?

#### Deprecating CloudFormation Custom Resource Global Table Support

Since L2 support would now be added that is using the CloudFormation resource, there is no need of the custom resource solution. This should be deprecated and users must be informed of this change.

#### RFC for migration path from Table construct to GlobalTable construct

There would be potential users who would like to move from Table construct to GlobalTable construct in their CDK app. We need to come up with a solution to support this use case. 

## Appendix

### Sample CloudFormation template generated

The following is the CFN template generated for the following code,

```typescript
  new GlobalTable(stack, 'FooTable', {
    partitionKey: { name: 'Foo', type: AttributeType.STRING },
  });
```

The generated template is,

```json
{
    "Resources": {
        "FooTable97478A04": {
            "Type": "AWS::DynamoDB::GlobalTable",
            "Properties": {
                "AttributeDefinitions": [
                    {
                        "AttributeName": "Foo",
                        "AttributeType": "S"
                    }
                ],
                "KeySchema": [
                    {
                        "AttributeName": "Foo",
                        "KeyType": "HASH"
                    }
                ],
                "Replicas": [
                    {
                        "ContributorInsightsSpecification": {
                            "Enabled": false
                        },
                        "DeletionProtectionEnabled": false,
                        "GlobalSecondaryIndexes": [],
                        "Region": "us-west-2",
                        "TableClass": "STANDARD"
                    }
                ],
                "BillingMode": "PAY_PER_REQUEST",
                "SSESpecification": {
                    "SSEEnabled": false
                }
            },
            "UpdateReplacePolicy": "Retain",
            "DeletionPolicy": "Retain"
        }
    },
    "Parameters": {
        "BootstrapVersion": {
            "Type": "AWS::SSM::Parameter::Value<String>",
            "Default": "/cdk-bootstrap/hnb659fds/version",
            "Description": "Version of the CDK Bootstrap resources in this environment, automatically retrieved from SSM Parameter Store. [cdk:skip]"
        }
    },
    "Rules": {
        "CheckBootstrapVersion": {
            "Assertions": [
                {
                    "Assert": {
                        "Fn::Not": [
                            {
                                "Fn::Contains": [
                                    [
                                        "1",
                                        "2",
                                        "3",
                                        "4",
                                        "5"
                                    ],
                                    {
                                        "Ref": "BootstrapVersion"
                                    }
                                ]
                            }
                        ]
                    },
                    "AssertDescription": "CDK bootstrap stack version 6 required. Please run 'cdk bootstrap' with a recent version of the CDK CLI."
                }
            ]
        }
    }
}
```